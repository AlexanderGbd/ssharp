<!-- 
This file contains modified version of Microsoft.CSharp.Core.targets from the Microsoft.Net.Compilers NuGet package.
The modification is required as we have to execute the CSC task twice during compilation of a S# project:
1. The first compilation is skipped by setting SkipCompilerExecution to true; this is the CSC task that Visual Studio 
   analyzes to initialize IntelliSense; the task therefore is passed all original C# files found in @(Compile)
2. The NormalizeSSharpCode target is executed; it rewrites the original C# code by applying S#'s code 
   normalizers. The generated files are stored in @(SSharpCmpile).
3. The actual compilation is done by the following CoreCompileSSharp task; it compiles the files (@SSharpCompile),
   integrating with the rest of the regular C# build process.
-->

<Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003" ToolsVersion="14.0">

	<PropertyGroup>
		<!-- always look for S# assemblies in the $(OutDir) -->
		<SSharpAssemblyDirectories>$(SSharpAssemblyDirectories);$(OutDir);$(MSBuildThisFileDirectory)../tools</SSharpAssemblyDirectories>
		
		<!-- Path to the S# LTSMin integration assembly -->
		<SSharpLtsMinAssemblyPath>$(MSBuildThisFileDirectory)../tools/SafetySharp.LtsMin.dll</SSharpLtsMinAssemblyPath>
    </PropertyGroup>
	
	<UsingTask TaskName="SSharpNormalizationTask" TaskFactory="CodeTaskFactory" AssemblyFile="$(MSBuildToolsPath)\Microsoft.Build.Tasks.Core.dll" >
		<ParameterGroup>
		  <InputFiles ParameterType="Microsoft.Build.Framework.ITaskItem[]" Required="true" />
		  <IntermediateDirectory ParameterType="Microsoft.Build.Framework.ITaskItem" Required="true" />
		  <References ParameterType="Microsoft.Build.Framework.ITaskItem[]" Required="true" />
		  <AssemblyDirectories ParameterType="Microsoft.Build.Framework.ITaskItem[]" Required="true" />
		  <OutputFiles ParameterType="Microsoft.Build.Framework.ITaskItem[]" Output="true" />
		</ParameterGroup>
		<Task>
			<Code Type="Class" Language="cs">
<![CDATA[
using System;
using System.IO;
using System.Linq;
using System.Security.Cryptography;
using System.Reflection;
using Microsoft.Build.Framework;
using Microsoft.Build.Utilities;

public class SSharpNormalizationTask : Task
{
	public SSharpNormalizationTask()
	{
		AppDomain.CurrentDomain.AssemblyResolve += (s, e) => TryLoadAssembly(new AssemblyName(e.Name));
	}

	[Required]
	public ITaskItem[] InputFiles { get; set; }
	
	[Required]
	public ITaskItem[] References { get; set; }

	[Required]
	public ITaskItem IntermediateDirectory { get; set; }

	[Required]
	public ITaskItem[] AssemblyDirectories { get; set; }

	[Output]
	public ITaskItem[] OutputFiles { get; set; }

	public override bool Execute()
	{
		try
		{
			var outPath = IntermediateDirectory.GetMetadata("FullPath");
			var intermediateDirectory = Path.Combine(outPath, "ssharp");
			Directory.CreateDirectory(intermediateDirectory);
		
			var compilationUnits = Normalize();
			if (compilationUnits == null)
				return false;
			
			OutputFiles = new ITaskItem[compilationUnits.Length];
			
			for (var i = 0; i < compilationUnits.Length; ++i)
			{
				var path = Path.Combine(intermediateDirectory, i + ".cs");

				OutputFiles[i] = new TaskItem(path);
				File.WriteAllText(path, "#if CompilingSSharpCode\n" + compilationUnits[i] + "\n#endif");
			}

			return true;
		}
		catch (TargetInvocationException e)
		{
			ReportException(e.InnerException);
			return false;
		}
		catch (Exception e)
		{
			ReportException(e);		
			return false;
		}
	}
	
	private void ReportException(Exception e)
	{
		Log.LogError("S# normalization failed due to an exception.");
		Log.LogError("{0}", e.Message);
		Log.LogError("{0}", e.StackTrace);
	}

	private Assembly TryLoadAssembly(AssemblyName assemblyName)
	{
		// Load the assemblies to memory first in order to avoid locking the actual assemblies on disk

		var referencePath =
			References.FirstOrDefault(rp => string.Equals(rp.GetMetadata("FileName"), assemblyName.Name, StringComparison.OrdinalIgnoreCase));
		if (referencePath != null)
			return Assembly.Load(File.ReadAllBytes(referencePath.GetMetadata("FullPath")));

		return LoadAssembly(assemblyName.Name + ".dll");
	}
	
	private Assembly LoadAssembly(string assemblyName)
	{
		foreach (var directory in AssemblyDirectories)
		{
			string fileName = Path.Combine(directory.GetMetadata("FullPath"), assemblyName);

			if (File.Exists(fileName))
				return Assembly.Load(File.ReadAllBytes(fileName));
		}
		
		return null;
	}

	private string[] Normalize()
	{
		var assembly = LoadAssembly("SafetySharp.Compiler.dll");
		if (assembly == null)
			throw new InvalidOperationException("Unable to find the S# compiler.");
		
		var compilerType = assembly.GetType("SafetySharp.Compiler.Compiler");

		var compiler = Activator.CreateInstance(compilerType, new[] { Log });
		var method = compilerType.GetMethod("NormalizeProject", BindingFlags.Instance | BindingFlags.Public);
		var normalize = (Normalizer)Delegate.CreateDelegate(typeof(Normalizer), compiler, method);

		return normalize(InputFiles.Select(f => f.ItemSpec).ToArray(), References.Select(r => r.ItemSpec).ToArray(), IntermediateDirectory.ItemSpec);
	}

	private delegate string[] Normalizer(string[] files, string[] references, string intermediateDirectory);
}
]]>
			</Code>
		</Task>
	</UsingTask>
	
    <Target Name="NormalizeSSharpCode" AfterTargets="CoreCompile">
        <SSharpNormalizationTask InputFiles="@(Compile)" References="@(ReferencePath)" IntermediateDirectory="$(IntermediateOutputPath)" AssemblyDirectories="$(SSharpAssemblyDirectories)">
			<Output TaskParameter="OutputFiles" ItemName="SSharpCompile" />
        </SSharpNormalizationTask>
		
		<ItemGroup>	
			<!-- make sure that the generated files are cleaned up -->
			<FileWrites Include="@(SSharpCompile)" />
		</ItemGroup>
		
		<Copy SourceFiles="$(SSharpLtsMinAssemblyPath)" DestinationFolder="$(OutDir)" Condition="Exists('$(SSharpLtsMinAssemblyPath)')"/>
	  
    </Target>
	
	<Import Project="SafetySharp.CSharp.Core.targets" />
  
</Project>